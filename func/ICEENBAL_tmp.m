function [  H,                                                          ...
            T,                                                          ...
            dH,                                                         ...
            dT  ]    =  ICEENBAL(T,f_ice,f_liq,k_liq,cv_ice,cv_liq,     ...
                        ro_ice,ro_liq,ro_sno,cp_liq,cp_sno,Ls,Lf,roLf,  ...
                        Rv,Tf,dz,delz,fn,dzdt,JJ,Tsfc,Sc,fcp,TL,TH,     ...
                        flmin,flmax,fcpsq,fcpsq2,ro_iwe,ro_wie)
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% liquid water fraction and the derivative of f_liq wrt to temperature
[  dFdT,                                                                ...
   f_wat ]  =  FREEZECURVE(T,f_liq,f_ice,ro_iwe,Tf,fcpsq,fcpsq2);

% vapor diffusion heat
   H_vap    =  VAPORHEAT(T,f_liq,f_ice,Tf,Rv,Ls);

% total enthalpy (expressed in W/m2 for intuitive comparison with fluxes)
   H_old    =  TOTALHEAT(T,f_liq,f_ice,cv_liq,cv_ice,roLf,Tf,H_vap,dzdt);
                 
% solve the heat equation
[  H,                                                                   ...
   T,                                                                   ...
   dH,                                                                  ...
   dT,                                                                  ...
   OK  ]    =  HEATSOLVE(T,H_old,f_wat,f_ice,f_liq,k_liq,cv_ice,cv_liq, ...
               ro_ice,ro_liq,ro_sno,cp_liq,cp_sno,dFdT,Ls,Lf,roLf,Rv,Tf,...
               dz,delz,fn,dzdt,JJ,Tsfc,Sc,fcp,TL,TH,flmin,flmax,fcpsq,  ...
               ro_iwe,ro_wie);
            
% 
% if a phase boundary was overshot, decrease the time step and start over
if OK == false && subfail < maxsubiter
   subfail     =  subfail+1;
   subiter     =  min(subiter+1,maxsubiter);
   dt_new      =  dt_max/subiter;
   H           =  xH;
   T           =  xT;
   Tsfc        =  xTsfc;

% note: we use xT and xTsfc b/c if a prior substep was successful, those
% values are valid. if we want to completely restart the timestep, we need:
% dt_sum=0, complete update_state, and reset df_liq_new.

   return;
else

% Substep was successful, update state (might move after full step)
[  T,                                                          ...
   f_ice,                                                      ...
   f_liq,                                                      ...
   d_liq,                                                      ...
   d_drn,                                                      ...
   k_eff,                                                      ...
   ro_sno,                                                     ...
   cp_sno,                                                     ...
   lcflag   ]  =  ICEMF(T,f_ice,f_liq,ro_ice,ro_liq,ro_air,    ...
                  cp_ice,cp_liq,k_liq,Lf,Ls,Rv,Tf,TL,f_liq_o,  ...
                  fcp,Sc,Sp,JJ_therm,f_min,d_liq,d_drn,fopts,  ...
                  ro_wie,ro_iwe,fcpsq,fcpsq2,opts);

   % allocate this step to the running total
   dt_sum      =  dt_sum + dt_new;

   % get the last successful substep AND the last timestep
   xH          =  H;
   xT          =  T;
   xTsfc       =  Tsfc;

   if TINY < dt-dt_sum && (dt_sum+dt_new)-dt > TINY
      dt_new  =   max(dt-dt_sum,dt_min);
      dt_flag =   true;
   end

end

   LCflag  =   logical(LCflag+lcflag);          % track layer combinations
