function [ice1, ice2] = skinmodel(opts) %#codegen

   % Define a logical flag that sets the simulation model
   isicemodel = strcmp(opts.simmodel, 'icemodel');

   % Load the physical constants
   [  cv_air, cv_liq, cv_ice, emiss, SB, epsilon, fcp, k_liq, Lf, ...
      Ls, Lv, ro_air, ro_ice, ro_liq, roLf, roLs, roLv, Rv, Tf] = ...
      icemodel.physicalConstant( ...
      'cv_air','cv_liq','cv_ice','emiss', 'SB','epsilon','fcp','k_liq','Lf', ...
      'Ls','Lv', 'ro_air','ro_ice','ro_liq','roLf','roLs','roLv', 'Rv','Tf');
   TINY = 1e-8;

   % Load the forcing data
   [tair, swd, lwd, albedo, wspd, rh, psfc, De, time] = METINIT(opts, 1);

   % Initialize the ice column
   [f_ice, f_liq, T, TL, TH, flmin, flmax, cp_sno, k_eff, dz, fn, delz, ...
      grid_therm, dz_therm, dz_spect, JJ_therm, JJ_spect, ~, Sp, scoef, ...
      ro_sno, ro_iwe, ro_wie, xTsfc, xf_liq, roL, Qc, f_min, fopts, ...
      liqflag, ice1, ice2] = ICEINIT(opts, tair);

   % INITIALIZE THE EXTINCTION COEFFICIENTS
   [total_solar, grid_spect, z_walls, spect_lower, spect_upper, solardwavl] = ...
      EXTCOEFSINIT(opts, dz_spect, JJ_spect, ro_ice);

   % INITIALIZE TIMESTEPPING
   [metiter, subiter, maxiter, maxsubiter, dt, dt_min, dt_max, dt_new, ...
      numyears, ~, numspinup] = INITTIMESTEPS(opts, time);

   %% START ITERATIONS OVER YEARS
   for thisyear = 1:numyears

      iter = 1;

      while iter <= maxiter

         % INITIALIZE NEW SUBSTEP
         [dt_sum, subfail, dt_flag, OK, d_liq, d_drn, d_evp] = ...
            INITSUBSTEP(f_liq);

         % SUBSURFACE SOLAR RADIATION SOURCE-TERM
         if swd(metiter) > 0 && isicemodel
            [Sc, chi] = UPDATEEXTCOEFS(swd(metiter), albedo(metiter), ...
               grid_spect, JJ_spect, dz_spect, grid_therm, JJ_therm, ...
               dz_therm, dz, z_walls, ro_sno, total_solar, spect_lower, ...
               spect_upper, solardwavl);
         else
            Sc = 0.0.*dz;
            chi = 1.0;
         end

         while dt_sum < dt

            % SURFACE TEMPERATURE
            % ea = VAPPRESS(rh(metiter), tair(metiter), liqflag);
            % Tsfc = fsearchzero(@(Tsfc) ...
            % chi * (1.0-albedo(metiter)) * swd(metiter) + emiss * lwd(metiter) ...
            % + Qc - emiss * SB * Tsfc^4 + cv_air * De(metiter) ...
            % * STABLEFN(tair(metiter), Tsfc, wspd(metiter), scoef) ...
            % * (tair(metiter)-Tsfc) + roL * De(metiter) * 0.622 / psfc(metiter) ...
            % * STABLEFN(tair(metiter), Tsfc, wspd(metiter), scoef) ...
            % * (ea - VAPOR(Tsfc, Tf, liqflag)), ...
            % xTsfc, xTsfc-50, xTsfc+50, tair(metiter), fopts.TolX);

            % SURFACE ENERGY BALANCE
            [Qm, Qf, Qh, Qe, Qc, ~, balance, Tsfc] = ENBALANCE( ...
               tair(metiter), wspd(metiter), rh(metiter), swd(metiter), ...
               lwd(metiter), albedo(metiter), psfc(metiter), De(metiter), ...
               T, k_eff, Tf, dz, chi, xTsfc, cv_air, emiss, SB, roL, scoef, ...
               epsilon, fopts, liqflag, opts, isicemodel);

            % SUBSURFACE ENERGY BALANCE
            k_eff = GETGAMMA(T, f_liq, f_ice, ro_ice, k_liq, Ls, Rv, Tf);
            [T, OK] = SKINSOLVE(Tsfc, T, k_eff, ro_sno, cp_sno, dz, dt_new, ...
               JJ_therm, fn, delz, f_liq, f_ice, Tf, Rv, Ls);

            % ERROR MESSAGE (SLOWS DOWN THE CODE A LOT)
            % fprintf('iter = %d (%.2f%%), dt = %.0f, success = %s\n', ...
            %    iter,100*iter/maxiter,dt_new,mat2str(OK))

            % [T, errH, errT, f_ice, f_liq, OK] = ICEENBAL(T, f_ice, f_liq, ...
            %    k_liq, cv_ice, cv_liq, ro_ice, ro_liq, ro_sno, cp_sno, Ls, ...
            %    Lf, roLf, Rv, Tf, dz, delz, fn, dt_new, JJ_therm, Tsfc, Sc, ...
            %    fcp, TL, TH, flmin, flmax, ro_iwe, ro_wie);

            % PHASE BOUNDARY OVERSHOOT, DECREASE THE TIME STEP AND START OVER
            if not(OK) && subfail < maxsubiter
               [subfail, subiter, dt_new, T, Tsfc, f_ice, f_liq] = ...
                  RESETSUBSTEP( xT, xTsfc, xf_ice, xf_liq, dt_max, subiter, ...
                  maxsubiter, subfail);
               continue
            else
               % UPDATE SURFACE FLUXES
               k_eff = GETGAMMA(T, f_liq, f_ice, ro_ice, k_liq, Ls, Rv, Tf);
               % [Qe, Qh, Qc, Qm, Qf, balance] = SEBFLUX(T, Tsfc, tair(metiter), ...
               %    swd(metiter), lwd(metiter), albedo(metiter), wspd(metiter), ...
               %    psfc(metiter), De(metiter), ea, Tf, k_eff, cv_air, roL, ...
               %    emiss, SB, epsilon, scoef, dz, liqflag, chi);

               % In the final version I did not use this, I just saved Qm, Qf, Qe
               % and computed runoff in POSTPROC/SRFRUNOFF
               % [surf_melt, surf_freeze, surf_subl, surf_cond, surf_runoff] = ...
               %    ICEABLATION(Qm, Qe, Qf, surf_melt, surf_freeze, surf_runoff,...
               %    surf_subl, surf_cond, ro_liq, Lf, Ls, dt, opts, ...
               %    dz, ro_ice, f_ice, f_liq);

               % COMPUTE MELT FREEZE
               % [T, f_ice, f_liq, d_liq, d_evp, d_drn] = ICEMF(T, f_ice, ...
               %    f_liq, ro_ice, ro_liq, cv_ice, cv_liq, Lf, Ls, Lv, ...
               %    Tf, TL, fcp, xf_liq, Sc, Sp, JJ_therm, f_min, fopts, ...
               %    dz_therm, dt_new, Qe, liqflag, ro_iwe, d_liq, d_drn, ...
               %    d_evp, flmin);

               % UPDATE DENSITY, HEAT CAPACITY, AND SUBSTEP TIME
               [ro_sno, cp_sno, liqflag, roL, xT, xTsfc, xf_liq, xf_ice, ...
                  dt_sum, dt_new, dt_flag] = ...
                  UPDATESUBSTEP(f_ice, f_liq, ro_ice, ro_liq, ro_air, cv_ice, ...
                  cv_liq, T, Tsfc, dt, dt_sum, dt_new, roLv, roLs, dt_min, TINY);
            end
         end

         % SAVE OUTPUT IF SPINUP IS FINISHED
         if thisyear >= numspinup
            [ice1, ice2] = SAVEOUTPUT(iter, ice1, ice2, ...
               opts.vars1, opts.vars2, ...
               {Tsfc, Qm, Qf, Qe, Qh, Qc, chi, balance, dt_sum},  ...
               {T, f_ice, f_liq});
         end

         % MOVE TO THE NEXT TIMESTEP
         [iter, metiter, subiter, dt_new] = NEXTSTEP(iter, metiter, subiter, ...
            dt_flag, dt_max, OK, dt_new);
      end % timesteps (one year)

      % RESTART THE MET DATA ITERATOR DURING SPIN UP
      if thisyear < numspinup
         metiter = 1;
         continue
      end

      % WRITE TO DISK
      WRITEOUTPUT(ice1, ice2, opts, thisyear-numspinup+1, ...
         time((thisyear-numspinup)*maxiter+1:(thisyear-numspinup+1)*maxiter), ...
         swd, lwd, albedo)
   end
end
